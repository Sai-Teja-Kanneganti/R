
```{r}
library (mlbench) # To access glass dataset.
library(car)# To access symbox function.
library(EnvStats) # To access boxcox function.
library(MASS) # To perform Linear Discriminant Analysis.
library(Amelia) # To access freetrade.
library(mice) # For multiple imputation.
library(VIM) # To evaluate K's nearest neighbour.
```
Problem 1(a)
```{r}
data (Glass) # To load Glass dataframe.
str(Glass) # To know structure of Glass.
Glass$Type <- as.numeric(Glass$Type) # Converting Type variable to numeric.
par(mfrow=c(3,3)) # To plot 9 graphs in single page.

hist(Glass$RI) # Histogram for RI variable in Glass dataframe.
hist(Glass$Na)
hist(Glass$Mg)
hist(Glass$Al)
hist(Glass$Si)
hist(Glass$K)
hist(Glass$Ca)
hist(Glass$Ba)
hist(Glass$Fe)
par(mfrow=c(1,1)) # Default parameters for plotting.
hist(Glass$Type)
```
Problem 1(b)
```{r}
Glass$K <- Glass$K + .1 # To make all values of Glass$K positive.
symbox(Glass$K, data=Glass, powers=c(3,2,1,0,-0.5,-1,-2)) # To assess which power makes Glass$K more symmetric.
Glass$Ba <- Glass$Ba + .1 # To make all values of Glass$Ba positive.
symbox(Glass$Ba, data=Glass, powers=c(3,2,1,0,-0.5,-1,-2)) # To assess which power makes Glass$Ba more symmetric.
Glass$Fe <- Glass$Fe + .1 # To make all values of Glass$Fe positive.
symbox(Glass$Fe, data=Glass, powers=c(3,2,1,0,-0.5,-1,-2)) # To assess which power makes Glass$Fe more symmetric.

detach("package:MASS", unload=TRUE) # Since MASS prevents execution of boxcox.
boxcox(Glass$K, optimize = TRUE, lambda=c(-3,3)) # To determine optimal value of Glass$K by boxcox method.
boxcox(Glass$Ba, optimize = TRUE, lambda=c(-3,3))
boxcox(Glass$Fe, optimize = TRUE, lambda=c(-3,3))
```
Problem 1(c)
```{r}
pc<-princomp(Glass,cor=TRUE,score=TRUE) # Principal component analysis with correlation.
summary(pc) # To get summary of principal components.
plot(pc) # plots pc
screeplot(pc,type = "line") # Elbow curve to prefict significant principal components.
```
Problem 1(d)
```{r}
library(MASS) # To perform LDA
ldaout<- lda(Type ~ RI+Na+Mg+Al+Si+K+Ca+Ba+Fe,data=Glass) # performing LDA considering Type as dependent variable and other variables are dependent in Glass data frame.
plot(ldaout) # plot the output of lda.
summary(ldaout) # Summary of output generated by lda.
ldapred <- predict(ldaout,Glass) # To predict data.
ldaclass <- ldapred$class # To classify data into which type of glass
ldatable <- table(ldaclass,Glass$Type) # creating table with 2 variables.
accuracy <- sum(diag(ldatable))/ sum(ldatable)* 100 # To measure accuracy of lda in percentage.
```
Problem 2
```{r}
library(Amelia) # To access freetrade.
data(freetrade) #Loads freetrade dataframe.
```
Problem 2(a)
```{r}
dflistwise <- freetrade # Creating dataframe dflistwise equal to freetrade.
datawithoutmiss <- na.omit(dflistwise) # This function removes complete row if any NA found in that row.
outputa <-lm(data=datawithoutmiss,tariff~ year+country+polity+pop+gdp.pc+intresmi+signed+fiveop+usheg)# Performing regression of datawithoutmiss(pairwise deletion).
summary(outputa)# summary of outputa
```
problem 2(b)
```{r}
dfMean <- freetrade # Creating dataframe dfMean equal to freetrade.
dfMean$tariff[which(is.na(dfMean$tariff))] <- mean(dfMean$tariff,na.rm=T)# Mean Imputation.
outputb <- lm(data=dfMean,tariff~ year+country+polity+pop+gdp.pc+intresmi+signed+fiveop+usheg) # Performing regression on dfMean
summary(outputb) # Summary of outputb
```
problem 2(c)
```{r}
dfMice <- freetrade # Creating dataframe dfMice equal to freetrade.
imp<-mice(dfMice,m=6,meth="mean",maxit = 10) #Applied Multivariate Imputation by Chained Equations with 6 multiple imputations by using "mean" method with 10 maximum iterations. 
fitc <-with(imp,lm(tariff~ year+country+polity+pop+gdp.pc+intresmi+signed+fiveop+usheg)) # regression applied.
summary(fitc) # Summary of fitc
est<-pool(fitc) # pools the results generated by repeated data analysis.
summary(est) # Summary of est.
```
problem 2(d)
```{r}
single <- freetrade # Creating dataframe single equal to freetrade.
apply(is.na(single), 2, any) # To find columns having missing values.

#imputaion by "hotdeck" (Imputed variable is tariff)

missing <- is.na(single$tariff) # Gives logical value for missing and not missing.
#sample m values from from the non-missing data (with replacement)
hotdeck <- single[!missing,"tariff"]  # create sample pool

n <- length(hotdeck)    #size of sample pool
m <- sum(missing)    #how many samples do I need?

hotdeck <- hotdeck[sample(n,m,replace=TRUE)]# select m values from n values with replacement.

single[missing,"tariff"]<-hotdeck # passing selected values to the single$tariff.

#imputation by mean  (Imputed variable is polity)

missing <- is.na(single$polity) # Gives logical value for missing and not missing for polity.
single[missing,"polity"]<-mean(single$polity,na.rm=T)   #imputation by mean

#imputation by "regression"  (Imputed variable is fiveop)

missing <- is.na(single$fiveop) # Gives logical value for missing and not missing for fiveop.
pickupvariable <- datawithoutmiss
pickupvariable <- datawithoutmiss [ ,-2] # Removing country variable since it is not numeric(We are finding pickup variable by corelation that suits fiveop.)
cor(pickupvariable, use="complete.obs", method="kendall") # correlation performed using kendall method.
fit<-lm(single$fiveop~single$year)    # fit a linear model to the data
f<-summary(fit)
print (f)  
str(f)
c<-f[[4]]                     # extract the coefficients 
se<-f[[6]]                    # extract the model standard error
single[missing,"fiveop"]<- (c[1] + c[2]*single[missing,"year"])# Imputation done by regression.  

#imputation by PMM   (Imputed variable is signed)

missing <- is.na(single$signed) # Gives logical value for missing and not missing for signed.
sum(missing) # gives number of missing values.
single$missing <- missing # new variable missing in single dataframe.
single[missing,"signed"] <- mice.impute.pmm(single$signed,!single$missing, single$year) # imputed by Predictive Mean Matching 
single <- single[  ,-11] # To delete missing data variable.

# k-nearest neighbor from VIM package (kNN imputation) (intresmi variable gets imputed)

single <- kNN(single[,1:10],k=5) # Performs KNN imputation for remaing columns from column 1 to column 10(intresmi gets imputed).
single <- single[,-c(11:20)] # Deleting extra columns generated.
apply(is.na(single), 2, any) # To check if columns have any missing values.

outputd <- lm(data=single,tariff~ year+country+polity+pop+gdp.pc+intresmi+signed+fiveop+usheg) # Performing regression on single
summary(outputd) # summary of outputd

```
Problem 3(a)
```{r}
bridgeSensor <- read.csv("E:/Masters/IDA/Assignments/Assignment 3/bridgeSensor.csv", header = TRUE, sep = ",") # read.csv() function to read tablular data & create a data frame.


#helper function to plot the frequency spectrum based 
plot.frequency.spectrum <- function(X.k, xlimits=c(0,length(X.k)/2)) {
  plot.bridgeSensor  <- cbind(0:(length(X.k)-1), Mod(X.k))
 
  plot(plot.bridgeSensor, t="h", lwd=2, main="", 
       xlab="Frequency (Hz)", ylab="Strength", 
       xlim=xlimits, ylim=c(0,max(Mod(plot.bridgeSensor[,2]))))
}


#create some fake data for an example
#this data will be composed of exactly 3 sine waves with a known amplitude and frequency

acq.freq <- 100                    # data acquisition (sample) frequency (Hz)
time     <- 6                      # measuring time interval (seconds)
ts       <- seq(0,time-1/acq.freq,1/acq.freq) # vector of sampling time-points (s) 
w   <- 2*pi/time

#create the fake wave data
wave<-1.5*sin(3*w*ts) + 0.5*sin(7*w*ts) + 0.75*sin(10*w*ts)

#and plot
plot(ts,wave,type="l"); title("Eg complex wave"); abline(h=0,lty=3)


#apply the fast fourier transform
X.k <- fft(wave)    

#plot the frequency spectrum 
# -- notice we will recover the frequencies 3, 7, and 10
# -- as well as their relative strengths
plot.frequency.spectrum(X.k,xlimits=c(0,20))

```
